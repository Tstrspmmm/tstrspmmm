<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Espresso Scale Logger</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#000; color:#fff;
                 font-family:-apple-system,BlinkMacSystemFont,sans-serif; }
    video, canvas { position:absolute; top:0; left:0; width:100%; height:100%; object-fit:cover; }
    #overlay { z-index:2; pointer-events:none; }
    #current { position:absolute; top:50%; width:100%; text-align:center;
               transform:translateY(-50%); font-size:3em; z-index:3; pointer-events:none; }
    .ui { position:absolute; top:10px; left:10px; z-index:4; display:flex; gap:8px; }
    .ui button { padding:6px 12px; background:rgba(255,255,255,0.1);
                  border:none; border-radius:6px; color:#fff; }
    .log, .graph { position:absolute; bottom:0; width:100%; max-height:40%;
                   background:rgba(0,0,0,0.7); overflow-y:auto; font-size:14px;
                   padding:10px; display:none; z-index:3; }
    .log.active, .graph.active { display:block!important; }
    #debug { position:absolute; top:10px; right:10px; background:#f00;
             padding:4px 8px; font-size:12px; display:none; z-index:4; color:#fff; }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="proc" style="display:none"></canvas>
  <canvas id="overlay"></canvas>
  <div id="current">â€“ g</div>
  <div class="ui">
    <button id="btnLog">Log</button>
    <button id="btnGraph">Graph</button>
    <button id="btnDebug">Debug</button>
    <button id="btnCSV">Export CSV</button>
  </div>
  <div id="log" class="log active"></div>
  <canvas id="graph" class="graph"></canvas>
  <div id="debug">DEBUG</div>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/master/opencv.js"
          onload="cv['onRuntimeInitialized']=()=>window.cvReady=true;"></script>
  <script>
  (async ()=> {
    // 1) Get camera access immediately
    const video = document.getElementById('video');
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode:'environment', width:{ideal:1280}, height:{ideal:720} },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
    } catch (e) {
      alert('Camera access is required.');
      console.error(e);
      return;
    }

    // 2) Wait for OpenCV
    while (!window.cvReady) await new Promise(r => setTimeout(r, 50));

    // 3) Setup canvases & contexts
    const proc     = document.getElementById('proc');
    const pctx     = proc.getContext('2d');
    const overlay  = document.getElementById('overlay');
    const ovCtx    = overlay.getContext('2d');
    const currentEl= document.getElementById('current');
    const logEl    = document.getElementById('log');
    const graphEl  = document.getElementById('graph');
    const gctx     = graphEl.getContext('2d');
    const debugEl  = document.getElementById('debug');
    const btnLog   = document.getElementById('btnLog');
    const btnGraph = document.getElementById('btnGraph');
    const btnDebug = document.getElementById('btnDebug');
    const btnCSV   = document.getElementById('btnCSV');

    // 4) UI state
    let showLog=true, debug=false;
    btnLog.onclick   = ()=> toggle(true);
    btnGraph.onclick = ()=> toggle(false);
    btnDebug.onclick = ()=> { debug = !debug; debugEl.style.display = debug?'block':'none'; };
    btnCSV.onclick   = downloadCSV;

    function toggle(l) {
      showLog = l;
      logEl.classList.toggle('active', l);
      graphEl.classList.toggle('active', !l);
      if (!l) drawGraph();
    }

    // 5) Logging & graph
    let dataLog = [], lastWeight = 0, lastChange = Date.now(), autoStarted=false;
    const ZERO_MARGIN=0.5, ZERO_COUNT=10, zeroBuf=[];

    function logWeight(w) {
      const now = Date.now();
      if (dataLog.length) {
        const dt = (now - dataLog[dataLog.length-1].time)/1000;
        const dr = (w - dataLog[dataLog.length-1].weight)/dt;
        logEl.innerText += `\n${w} g @ ${dr.toFixed(2)} g/s`;
      } else {
        logEl.innerText = `${w} g`;
      }
      dataLog.push({weight:w, time:now});
      logEl.scrollTop = logEl.scrollHeight;
    }

    function drawGraph() {
      graphEl.width  = window.innerWidth;
      graphEl.height = window.innerHeight * 0.4;
      gctx.clearRect(0,0,graphEl.width,graphEl.height);
      const now = Date.now();
      const recent = dataLog.filter(d=>now - d.time <= 60000);
      if (recent.length < 2) return;
      const t0 = recent[0].time, t1 = recent[recent.length-1].time;
      const w0 = Math.min(...recent.map(d=>d.weight)), w1 = Math.max(...recent.map(d=>d.weight));
      gctx.beginPath();
      recent.forEach((d,i)=>{
        const x = ((d.time-t0)/(t1-t0)) * graphEl.width;
        const y = graphEl.height - ((d.weight-w0)/(w1-w0)) * graphEl.height;
        i ? gctx.lineTo(x,y) : gctx.moveTo(x,y);
      });
      gctx.strokeStyle = 'lime';
      gctx.lineWidth = 2;
      gctx.stroke();
    }

    function downloadCSV() {
      const csv = 'time,weight\n' +
        dataLog.map(d=>`${new Date(d.time).toISOString()},${d.weight}`).join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const url  = URL.createObjectURL(blob);
      const a    = document.createElement('a');
      a.href     = url;
      a.download = 'espresso_log.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    // 6) 7-segment definitions
    const segDefs = {
      a:{x:0.18,y:0.02,w:0.64,h:0.12},
      b:{x:0.82,y:0.18,w:0.12,h:0.32},
      c:{x:0.82,y:0.54,w:0.12,h:0.32},
      d:{x:0.18,y:0.88,w:0.64,h:0.12},
      e:{x:0.06,y:0.54,w:0.12,h:0.32},
      f:{x:0.06,y:0.18,w:0.12,h:0.32},
      g:{x:0.18,y:0.45,w:0.64,h:0.10}
    };
    const digitMap = {
      0:['a','b','c','d','e','f'],
      1:['b','c'],
      2:['a','b','g','e','d'],
      3:['a','b','g','c','d'],
      4:['f','g','b','c'],
      5:['a','f','g','c','d'],
      6:['a','f','g','e','c','d'],
      7:['a','b','c'],
      8:['a','b','c','d','e','f','g'],
      9:['a','b','c','d','f','g']
    };

    // 7) OpenCV mats init
    let src, gray, thresh, contours, hierarchy;
    function initMats() {
      const w = video.videoWidth, h = video.videoHeight;
      proc.width  = w; proc.height = h;
      src     = new cv.Mat(h, w, cv.CV_8UC4);
      gray    = new cv.Mat(h, w, cv.CV_8UC1);
      thresh  = new cv.Mat(h, w, cv.CV_8UC1);
      contours= new cv.MatVector();
      hierarchy=new cv.Mat();
    }

    // 8) Find display box
    function findDisplay() {
      pctx.drawImage(video, 0, 0, proc.width, proc.height);
      src.data.set(pctx.getImageData(0,0,proc.width,proc.height).data);
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.threshold(gray, thresh, 0,255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
      cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      let best=null, bestArea=0;
      for (let i=0; i<contours.size(); i++) {
        const cnt = contours.get(i);
        const r   = cv.boundingRect(cnt);
        const ar  = r.width / r.height;
        const area= r.width * r.height;
        if (ar>3 && ar<10 && area>5000 && area>bestArea) {
          bestArea = area;
          best     = r;
        }
      }
      return best;
    }

    // 9) Extract digit contours
    function extractDigitRegions(binIm, w, h) {
      const src2   = cv.matFromImageData(binIm);
      const gray2  = new cv.Mat(), thr2 = new cv.Mat();
      cv.cvtColor(src2, gray2, cv.COLOR_RGBA2GRAY);
      cv.threshold(gray2, thr2, 128,255,cv.THRESH_BINARY);
      const ctr2   = new cv.MatVector(), hier2 = new cv.Mat();
      cv.findContours(thr2, ctr2, hier2, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      const boxes=[];
      for(let i=0;i<ctr2.size();i++){
        const cnt = ctr2.get(i);
        const r   = cv.boundingRect(cnt);
        const ar  = r.width/r.height, area=r.width*r.height;
        if(area>500 && ar>0.3 && ar<1.2){
          const can = document.createElement('canvas');
          can.width = r.width; can.height = r.height;
          const dctx = can.getContext('2d');
          dctx.putImageData(binIm, -r.x, -r.y);
          boxes.push({x:r.x,y:r.y,w:r.width,h:r.height,im:dctx.getImageData(0,0,r.width,r.height)});
        }
      }
      src2.delete(); gray2.delete(); thr2.delete(); ctr2.delete(); hier2.delete();
      boxes.sort((a,b)=>a.x - b.x);
      return boxes;
    }

    // 10) 7-seg recognize one digit
    function recognize7Seg(im, w, h) {
      const d = im.data;
      for(let i=0;i<d.length;i+=4){
        const m = (d[i]+d[i+1]+d[i+2])/3;
        d[i]=d[i+1]=d[i+2]= m>128?255:0;
      }
      const mask={};
      for(const [s,def] of Object.entries(segDefs)){
        const rx = Math.floor(def.x*w),
              ry = Math.floor(def.y*h),
              rw = Math.ceil(def.w*w),
              rh = Math.ceil(def.h*h);
        let on=0, tot=0;
        for(let y=ry;y<ry+rh;y++){
          for(let x=rx;x<rx+rw;x++){
            const idx=(y*w+x)*4;
            if(d[idx]>128) on++;
            tot++;
          }
        }
        mask[s] = on/tot > 0.5;
      }
      for(let dig=0; dig<=9; dig++){
        const segs = digitMap[dig];
        if(segs.every(s=>mask[s]) &&
           Object.keys(mask).filter(s=>mask[s]).length===segs.length) {
          return dig;
        }
      }
      return 0;
    }

    // 11) Main render loop
    function render() {
      if(video.readyState<2) {
        requestAnimationFrame(render);
        return;
      }
      if(!src) initMats();

      const box = findDisplay();
      ovCtx.clearRect(0,0,overlay.width=innerWidth, overlay.height=innerHeight);

      let weight = 0;
      if(box) {
        // draw display box
        const sx=innerWidth/video.videoWidth, sy=innerHeight/video.videoHeight;
        ovCtx.strokeStyle='cyan'; ovCtx.lineWidth=3;
        ovCtx.strokeRect(box.x*sx, box.y*sy, box.width*sx, box.height*sy);

        // get ROI pixels
        const im = pctx.getImageData(box.x,box.y,box.width,box.height);
        // threshold for digit regions
        for(let i=0;i<im.data.length;i+=4){
          const m=(im.data[i]+im.data[i+1]+im.data[i+2])/3;
          im.data[i]=im.data[i+1]=im.data[i+2]=m>128?255:0;
        }
        // extract each digit
        const regs = extractDigitRegions(im, box.width, box.height);
        // draw each digit box if debug
        if(debug){
          regs.forEach(r=>{
            ovCtx.strokeStyle='yellow';
            const x = (box.x + r.x)*sx, y = (box.y + r.y)*sy;
            ovCtx.strokeRect(x, y, r.w*sx, r.h*sy);
          });
        }
        // recognize digits
        weight = parseInt(regs.map(r=>recognize7Seg(r.im,r.w,r.h)).join(''),10) || 0;
      }

      // update readout & logging state
      currentEl.textContent = weight + ' g';
      const now = Date.now();
      if(!autoStarted) {
        if(weight <= ZERO_MARGIN) zeroBuf.push(now);
        else if(zeroBuf.length >= ZERO_COUNT) {
          autoStarted = true;
          dataLog = [];
          logEl.innerText = '[Auto-start]';
          lastChange = now;
          logWeight(weight);
        }
        if(zeroBuf.length > ZERO_COUNT) zeroBuf.shift();
      } else {
        logWeight(weight);
        if(Math.abs(weight-lastWeight)>0.2) lastChange = now;
        if(now - lastChange > 10000) {
          autoStarted = false;
          zeroBuf.length = 0;
          logEl.innerText += '\n[Reset]';
        }
      }
      lastWeight = weight;
      if(showLog) logEl.scrollTop = logEl.scrollHeight;

      requestAnimationFrame(render);
    }

    // kick off
    requestAnimationFrame(render);

  })();
  </script>
</body>
</html>
