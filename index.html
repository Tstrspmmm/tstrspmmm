<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Espresso Scale Logger</title>
  <style>
    html,body{margin:0;padding:0;overflow:hidden;background:#000;color:#fff;
      font-family:-apple-system,BlinkMacSystemFont,sans-serif;}
    video,canvas{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;}
    #overlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:2;}
    #current{position:absolute;top:50%;width:100%;text-align:center;
      transform:translateY(-50%);font-size:3em;z-index:3;pointer-events:none;}
    .ui{position:absolute;top:10px;left:10px;z-index:4;display:flex;gap:8px;}
    .ui button{padding:6px 12px;background:rgba(255,255,255,0.1);border:none;
      border-radius:6px;color:#fff;font-size:14px;}
    .log,.graph{position:absolute;bottom:0;width:100%;max-height:40%;
      background:rgba(0,0,0,0.7);overflow-y:auto;font-size:14px;padding:10px;
      display:none;z-index:3;}
    .log.active,.graph.active{display:block!important;}
    #debug{position:absolute;top:10px;right:10px;background:#f00;padding:4px 8px;
      font-size:12px;display:none;z-index:4;color:#fff;}
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="proc" style="display:none"></canvas>
  <canvas id="overlay"></canvas>
  <div id="current">â€“ g</div>

  <div class="ui">
    <button id="btnLog">Log</button>
    <button id="btnGraph">Graph</button>
    <button id="btnDebug">Debug</button>
    <button id="btnCSV">Export CSV</button>
  </div>

  <div id="log" class="log active"></div>
  <canvas id="graph" class="graph"></canvas>
  <div id="debug">DEBUG</div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
  <script>
  (async()=> {
    // 1. CAMERA SETUP (prompt immediately)
    const video = document.getElementById('video');
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode:'environment', width:{ideal:1280}, height:{ideal:720} },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
    } catch (err) {
      alert('Camera access required.');
      console.error(err);
      return;
    }

    // 2. CANVASES & UI REFS
    const proc    = document.getElementById('proc');
    const pctx    = proc.getContext('2d');
    const overlay = document.getElementById('overlay');
    const octx    = overlay.getContext('2d');
    const current = document.getElementById('current');
    const logEl   = document.getElementById('log');
    const graph   = document.getElementById('graph');
    const gctx    = graph.getContext('2d');
    const debugEl = document.getElementById('debug');
    const btnLog  = document.getElementById('btnLog');
    const btnGraph= document.getElementById('btnGraph');
    const btnDebug= document.getElementById('btnDebug');
    const btnCSV  = document.getElementById('btnCSV');

    // 3. TESSERACT WORKER
    const worker = Tesseract.createWorker({
      logger: m => debug && console.log(m)
    });
    await worker.load();
    await worker.loadLanguage('eng');
    await worker.initialize('eng');
    await worker.setParameters({
      tessedit_char_whitelist: '0123456789',
      preserve_interword_spaces: '0'
    });

    // 4. STATE & UI LOGIC
    let showLog=true, debug=false;
    const ZERO_MARGIN = 0.5, ZERO_COUNT = 10;
    let zeroBuf = [], autoStarted=false;
    let dataLog = [], lastWeight=0, lastChange=Date.now();

    btnLog.onclick   = ()=>toggle(true);
    btnGraph.onclick = ()=>toggle(false);
    btnDebug.onclick = ()=>{ debug = !debug; debugEl.style.display = debug?'block':'none'; };
    btnCSV.onclick   = () => {
      const csv = 'time,weight\n' + dataLog.map(d=>`${new Date(d.time).toISOString()},${d.weight}`).join('\n');
      const blob = new Blob([csv],{type:'text/csv'}), url=URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='espresso.csv'; a.click();
      URL.revokeObjectURL(url);
    };

    function toggle(l) {
      showLog = l;
      logEl.classList.toggle('active', l);
      graph.classList.toggle('active', !l);
      if (!l) drawGraph();
    }

    function drawGraph() {
      graph.width = innerWidth;
      graph.height= innerHeight * 0.4;
      gctx.clearRect(0,0,graph.width,graph.height);
      const now = Date.now();
      const recent = dataLog.filter(d=>now - d.time <= 60000);
      if (recent.length < 2) return;
      const t0 = recent[0].time, t1 = recent[recent.length-1].time;
      const w0 = Math.min(...recent.map(d=>d.weight)), w1 = Math.max(...recent.map(d=>d.weight));
      gctx.beginPath();
      recent.forEach((d,i) => {
        const x = ((d.time-t0)/(t1-t0)) * graph.width;
        const y = graph.height - ((d.weight-w0)/(w1-w0)) * graph.height;
        i ? gctx.lineTo(x,y) : gctx.moveTo(x,y);
      });
      gctx.strokeStyle='lime';
      gctx.lineWidth=2;
      gctx.stroke();
    }

    function logWeight(w) {
      const now=Date.now();
      if (dataLog.length) {
        const dt = (now-dataLog[dataLog.length-1].time)/1000;
        const dr = (w-dataLog[dataLog.length-1].weight)/dt;
        logEl.innerText += `\n${w} g @ ${dr.toFixed(2)} g/s`;
      } else {
        logEl.innerText = `${w} g`;
      }
      dataLog.push({weight:w, time:now});
      logEl.scrollTop = logEl.scrollHeight;
    }

    // 5. BRIGHT-PIXEL ROI DETECTION + OCR LOOP
    proc.width = video.videoWidth;
    proc.height= video.videoHeight;
    overlay.width  = innerWidth;
    overlay.height = innerHeight;

    setInterval(async ()=> {
      if (video.readyState < 2) return;

      // draw current frame
      pctx.drawImage(video, 0, 0, proc.width, proc.height);
      const img = pctx.getImageData(0,0,proc.width,proc.height);
      const data = img.data;

      // find bounding box of bright pixels
      let minX=proc.width, minY=proc.height, maxX=0, maxY=0;
      const T = 200; // brightness threshold
      for (let i=0; i<data.length; i+=4) {
        const brightness = (data[i]+data[i+1]+data[i+2]) / 3;
        if (brightness > T) {
          const idx = i/4;
          const x = idx % proc.width, y = Math.floor(idx / proc.width);
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      }
      // add small margin
      const M = 8;
      minX = Math.max(0, minX-M);
      minY = Math.max(0, minY-M);
      maxX = Math.min(proc.width, maxX+M);
      maxY = Math.min(proc.height, maxY+M);

      // clear overlay
      octx.clearRect(0,0,overlay.width,overlay.height);
      // draw ROI on overlay
      const scaleX = overlay.width / proc.width;
      const scaleY = overlay.height/ proc.height;
      octx.strokeStyle = 'cyan';
      octx.lineWidth = 3;
      octx.strokeRect(minX*scaleX, minY*scaleY,
                      (maxX-minX)*scaleX, (maxY-minY)*scaleY);

      // crop ROI into temp canvas
      const w = maxX-minX, h = maxY-minY;
      if (w < 20 || h < 20) return;  // too small
      const crop = document.createElement('canvas');
      crop.width = w; crop.height = h;
      const cctx = crop.getContext('2d');
      cctx.putImageData(pctx.getImageData(minX, minY, w, h), 0, 0);

      // OCR the crop
      const { data: { text } } = await worker.recognize(crop);
      const digits = text.replace(/[^0-9]/g,'');
      const weight = digits.length ? parseInt(digits,10) : 0;

      // display live
      current.textContent = weight + ' g';

      // auto-start logic
      const now = Date.now();
      if (!autoStarted) {
        if (weight <= ZERO_MARGIN) zeroBuf.push(now);
        else if (zeroBuf.length >= ZERO_COUNT) {
          autoStarted = true;
          dataLog = [];
          logEl.innerText = '[Auto-start]';
          lastChange = now;
          logWeight(weight);
        }
        if (zeroBuf.length > ZERO_COUNT) zeroBuf.shift();
      } else {
        logWeight(weight);
        if (Math.abs(weight - lastWeight) > 0.5) lastChange = now;
        if (now - lastChange > 10000) {
          autoStarted = false;
          zeroBuf = [];
          logEl.innerText += '\n[Reset]';
        }
      }
      lastWeight = weight;

      // update log scroll
      if (showLog) logEl.scrollTop = logEl.scrollHeight;

    }, 300);

  })();
  </script>
</body>
</html>
