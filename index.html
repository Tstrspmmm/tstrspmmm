<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Espresso Scale Logger</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#000; color:#fff;
      font-family:-apple-system,BlinkMacSystemFont,sans-serif; }
    video, canvas { position:absolute; top:0; left:0; width:100%; height:100%; object-fit:cover; }
    /* overlayCanvas sits above video to draw boxes/text */
    #overlayCanvas { z-index:2; pointer-events:none; }
    .ui { position:absolute; top:10px; left:10px; z-index:4; display:flex; gap:8px; }
    .ui button { padding:6px 12px; background:rgba(255,255,255,0.1); border:none; border-radius:6px; color:#fff; }
    #current { position:absolute; top:50%; width:100%; text-align:center; transform:translateY(-50%); font-size:3em; z-index:3; }
    .log, .graph { position:absolute; bottom:0; width:100%; max-height:40%; background:rgba(0,0,0,0.7);
      overflow-y:auto; font-size:14px; padding:10px; display:none; z-index:3; }
    .log.active, .graph.active { display:block !important; }
    .roi { position:absolute; border:2px dashed #0f0; box-sizing:border-box;
      width:60%; height:15%; top:42.5%; left:20%; z-index:1; pointer-events:none; }
    #debug { position:absolute; top:10px; right:10px; background:#f00; padding:4px 8px;
      font-size:12px; display:none; z-index:4; color:#fff; }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="procCanvas" style="display:none"></canvas>
  <canvas id="roiCanvas" style="display:none"></canvas>
  <canvas id="overlayCanvas"></canvas>
  <div id="current">–.– g</div>
  <div class="ui">
    <button id="btnLog">Log</button>
    <button id="btnGraph">Graph</button>
    <button id="btnDebug">Debug</button>
    <button id="btnPreproc">Preproc Off</button>
  </div>
  <div id="log" class="log active"></div>
  <canvas id="graph" class="graph"></canvas>
  <div class="roi"></div>
  <div id="debug">DEBUG</div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
  <script>
  (async () => {
    // DOM refs
    const video = document.getElementById('video');
    const procCanvas = document.getElementById('procCanvas');
    const procCtx    = procCanvas.getContext('2d');
    const roiCanvas  = document.getElementById('roiCanvas');
    const roiCtx     = roiCanvas.getContext('2d');
    const overlay    = document.getElementById('overlayCanvas');
    const ovCtx      = overlay.getContext('2d');
    const currentEl  = document.getElementById('current');
    const logEl      = document.getElementById('log');
    const graphEl    = document.getElementById('graph');
    const graphCtx   = graphEl.getContext('2d');
    const debugEl    = document.getElementById('debug');
    const btnLog     = document.getElementById('btnLog');
    const btnGraph   = document.getElementById('btnGraph');
    const btnDebug   = document.getElementById('btnDebug');
    const btnPreproc = document.getElementById('btnPreproc');

    // state
    let showLog = true, debug=false, preprocess=false;
    let worker, workerReady=false, ocrBusy=false;
    let dataLog=[], zeroBuf=[], autoStarted=false;
    const ZERO_COUNT=10, ZERO_MARGIN=0.5;
    let lastWeight=0, lastChange=Date.now();

    // initialize overlay canvas to fill screen
    function resizeOverlay(){
      overlay.width = window.innerWidth;
      overlay.height= window.innerHeight;
    }
    window.addEventListener('resize', resizeOverlay);
    resizeOverlay();

    // Tesseract worker
    worker = Tesseract.createWorker({ logger: m => debug && console.log(m) });
    await worker.load(); await worker.loadLanguage('eng');
    await worker.initialize('eng');
    workerReady=true;

    // camera
    const stream = await navigator.mediaDevices.getUserMedia({
      video:{ facingMode:'environment', width:{ideal:1920}, height:{ideal:1080} },
      audio:false
    });
    video.srcObject = stream;

    // UI
    btnLog.onclick   = ()=> toggleView(true);
    btnGraph.onclick = ()=> toggleView(false);
    btnDebug.onclick = ()=>{
      debug = !debug;
      debugEl.style.display = debug?'block':'none';
    };
    btnPreproc.onclick = ()=>{
      preprocess = !preprocess;
      btnPreproc.textContent = preprocess?'Preproc On':'Preproc Off';
    };
    function toggleView(toLog){
      showLog=toLog;
      logEl.classList.toggle('active',toLog);
      graphEl.classList.toggle('active',!toLog);
      if(!toLog) drawGraph();
    }

    // graph & logging
    function drawGraph(){
      graphEl.width = window.innerWidth;
      graphEl.height= window.innerHeight*0.4;
      graphCtx.clearRect(0,0,graphEl.width,graphEl.height);
      const now=Date.now(), recent=dataLog.filter(d=>now-d.time<=60000);
      if(recent.length<2) return;
      const t0=recent[0].time, t1=recent.pop().time;
      const w0=Math.min(...recent.map(d=>d.weight)), w1=Math.max(...recent.map(d=>d.weight));
      graphCtx.beginPath();
      recent.forEach((d,i)=>{
        const x=((d.time-t0)/(t1-t0))*graphEl.width;
        const y=graphEl.height-((d.weight-w0)/(w1-w0))*graphEl.height;
        i?graphCtx.lineTo(x,y):graphCtx.moveTo(x,y);
      });
      graphCtx.strokeStyle='lime'; graphCtx.lineWidth=2; graphCtx.stroke();
    }
    function logWeight(w){
      const now=Date.now();
      if(dataLog.length){
        const dt=(now-dataLog[dataLog.length-1].time)/1000;
        const dr=(w-dataLog[dataLog.length-1].weight)/dt;
        logEl.innerText+=`\n${w.toFixed(1)} g @ ${dr.toFixed(2)} g/s`;
      } else {
        logEl.innerText=`${w.toFixed(1)} g`;
      }
      dataLog.push({weight:w,time:now});
      logEl.scrollTop=logEl.scrollHeight;
    }

    // main OCR loop
    setInterval(async ()=>{
      if(!workerReady||ocrBusy||video.readyState<2) return;
      ocrBusy=true;

      // draw video to proc canvas
      const vw=video.videoWidth, vh=video.videoHeight;
      procCanvas.width=vw; procCanvas.height=vh;
      procCtx.drawImage(video,0,0,vw,vh);

      // define ROI crop
      const rx=vw*0.2, ry=vh*0.425, rw=vw*0.6, rh=vh*0.15;
      const frame=procCtx.getImageData(rx,ry,rw,rh);
      if(preprocess){
        for(let i=0,d=frame.data;i<d.length;i+=4){
          const m=(d[i]+d[i+1]+d[i+2])/3;
          d[i]=d[i+1]=d[i+2]=m>128?255:0;
        }
      }
      // draw to roi canvas
      roiCanvas.width=rw; roiCanvas.height=rh;
      roiCtx.putImageData(frame,0,0);

      // OCR
      const { data } = await worker.recognize(roiCanvas);
      const words = data.words.filter(w=>/^[0-9.]+$/.test(w.text));
      let best = words.sort((a,b)=>b.confidence-a.confidence)[0];
      let num = best ? parseFloat(best.text) : 0;

      // show bounding box & text
      ovCtx.clearRect(0,0,overlay.width,overlay.height);
      if(best){
        // map word bbox back to screen coords
        const scaleX=overlay.width / vw;
        const scaleY=overlay.height/ vh;
        const x = (rx+best.bbox.x0) * scaleX;
        const y = (ry+best.bbox.y0) * scaleY;
        const w = (best.bbox.x1-best.bbox.x0) * scaleX;
        const h = (best.bbox.y1-best.bbox.y0) * scaleY;
        ovCtx.strokeStyle='cyan'; ovCtx.lineWidth=2;
        ovCtx.strokeRect(x,y,w,h);
        ovCtx.font=`${Math.max(16, h*0.6)}px monospace`;
        ovCtx.fillStyle='cyan';
        ovCtx.fillText(best.text, x, y-4);
      }

      // update live weight
      currentEl.textContent = num.toFixed(1)+' g';

      // auto-start logic
      const now = Date.now();
      if(!autoStarted){
        if(num<=ZERO_MARGIN) zeroBuf.push(now);
        else if(zeroBuf.length>=ZERO_COUNT){
          autoStarted=true; dataLog=[]; logEl.innerText='[Auto-start]';
          lastChange=now; logWeight(num);
        }
        if(zeroBuf.length>ZERO_COUNT) zeroBuf.shift();
      } else {
        logWeight(num);
        if(Math.abs(num-lastWeight)>0.2) lastChange=now;
        if(now-lastChange>10000){
          autoStarted=false; zeroBuf=[]; logEl.innerText+='\n[Reset]';
        }
      }
      lastWeight = num;

      ocrBusy=false;
      if(showLog) logEl.scrollTop=logEl.scrollHeight;
    }, 300);
  })();
  </script>
</body>
</html>
