<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Espresso Scale Logger</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#000; color:#fff;
      font-family:-apple-system,BlinkMacSystemFont,sans-serif; }
    video, canvas { position:absolute; top:0; left:0; width:100%; height:100%; object-fit:cover; }
    .overlay { position:absolute; inset:0; backdrop-filter:brightness(0.8); pointer-events:none; }
    .ui { position:absolute; top:10px; left:10px; z-index:3; display:flex; gap:8px; }
    .ui button { padding:6px 12px; background:rgba(255,255,255,0.1); border:none; border-radius:6px; color:#fff; }
    #current { position:absolute; top:50%; width:100%; text-align:center; transform:translateY(-50%); font-size:3em; z-index:2; pointer-events:none; }
    .log, .graph { position:absolute; bottom:0; width:100%; max-height:40%; background:rgba(0,0,0,0.7);
      overflow-y:auto; font-size:14px; padding:10px; display:none; z-index:2; }
    .log.active, .graph.active { display:block !important; }
    .roi { position:absolute; border:2px dashed #0f0; box-sizing:border-box;
      width:60%; height:15%; top:42.5%; left:20%; z-index:2; pointer-events:none; }
    #debug { position:absolute; top:10px; right:10px; background:#f00; padding:4px 8px;
      font-size:12px; display:none; z-index:3; color:#fff; }
  </style>
</head>
<body>
  <!-- video & hidden canvases -->
  <video id="video" autoplay playsinline></video>
  <canvas id="procCanvas" style="display:none"></canvas>
  <canvas id="roiCanvas" style="display:none"></canvas>
  <div class="overlay"></div>
  <!-- UI -->
  <div id="current">–.– g</div>
  <div class="ui">
    <button id="btnLog">Log</button>
    <button id="btnGraph">Graph</button>
    <button id="btnDebug">Debug</button>
    <button id="btnPreproc">Preproc Off</button>
  </div>
  <div id="log" class="log active"></div>
  <canvas id="graph" class="graph"></canvas>
  <div class="roi"></div>
  <div id="debug">DEBUG</div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
  <script>
  (async () => {
    // DOM
    const video = document.getElementById('video');
    const procCanvas = document.getElementById('procCanvas');
    const procCtx    = procCanvas.getContext('2d');
    const roiCanvas  = document.getElementById('roiCanvas');
    const roiCtx     = roiCanvas.getContext('2d');
    const currentEl  = document.getElementById('current');
    const logEl      = document.getElementById('log');
    const graphEl    = document.getElementById('graph');
    const graphCtx   = graphEl.getContext('2d');
    const debugEl    = document.getElementById('debug');
    const btnLog     = document.getElementById('btnLog');
    const btnGraph   = document.getElementById('btnGraph');
    const btnDebug   = document.getElementById('btnDebug');
    const btnPreproc = document.getElementById('btnPreproc');

    // State
    let showLog = true, debug = false, preprocess = false;
    let workerReady = false, worker;
    let dataLog = [], ocrBusy = false;
    let zeroBuffer = [], autoStarted = false;
    const ZERO_COUNT = 10, ZERO_MARGIN = 0.5; // ~3 s of zeros at 300ms
    let lastChange = Date.now(), lastWeight = 0;

    // INIT Tesseract worker
    worker = Tesseract.createWorker({ logger: m => debug && console.log(m) });
    await worker.load();
    await worker.loadLanguage('eng');
    await worker.initialize('eng');
    workerReady = true;

    // CAMERA
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode:'environment', width:{ideal:1920},height:{ideal:1080} },
      audio: false
    });
    video.srcObject = stream;

    // UI EVENTS
    btnLog.onclick   = ()=>toggleView(true);
    btnGraph.onclick = ()=>toggleView(false);
    btnDebug.onclick = ()=>{
      debug = !debug;
      debugEl.style.display = debug ? 'block':'none';
    };
    btnPreproc.onclick = ()=>{
      preprocess = !preprocess;
      btnPreproc.textContent = preprocess?'Preproc On':'Preproc Off';
    };

    function toggleView(toLog){
      showLog = !!toLog;
      logEl.classList.toggle('active', showLog);
      graphEl.classList.toggle('active', !showLog);
      if(!showLog) drawGraph();
    }

    function drawGraph(){
      graphEl.width  = window.innerWidth;
      graphEl.height = window.innerHeight * 0.4;
      graphCtx.clearRect(0,0,graphEl.width,graphEl.height);
      const now = Date.now();
      const recent = dataLog.filter(d=>now-d.time<=60000);
      if(recent.length<2) return;
      const t0 = recent[0].time, t1 = recent[recent.length-1].time;
      const w0 = Math.min(...recent.map(d=>d.weight)), w1 = Math.max(...recent.map(d=>d.weight));
      graphCtx.beginPath();
      recent.forEach((d,i)=>{
        const x = ((d.time-t0)/(t1-t0))*graphEl.width;
        const y = graphEl.height - ((d.weight-w0)/(w1-w0))*graphEl.height;
        i?graphCtx.lineTo(x,y):graphCtx.moveTo(x,y);
      });
      graphCtx.strokeStyle='lime';graphCtx.lineWidth=2;graphCtx.stroke();
    }

    function logWeight(w){
      const now = Date.now();
      if(dataLog.length){
        const dt = (now-dataLog[dataLog.length-1].time)/1000;
        const dr = (w-dataLog[dataLog.length-1].weight)/dt;
        logEl.innerText += `\n${w.toFixed(1)} g @ ${dr.toFixed(2)} g/s`;
      } else {
        logEl.innerText += `\n${w.toFixed(1)} g`;
      }
      dataLog.push({weight:w,time:now});
      logEl.scrollTop = logEl.scrollHeight;
    }

    // MAIN LOOP
    setInterval(async ()=>{
      if(!workerReady||ocrBusy||video.readyState<2) return;
      ocrBusy = true;

      // Setup canvases
      const vw=video.videoWidth, vh=video.videoHeight;
      procCanvas.width = vw; procCanvas.height = vh;
      roiCanvas.width  = vw*0.6; roiCanvas.height = vh*0.15;
      // Draw frame & extract ROI
      procCtx.drawImage(video,0,0,vw,vh);
      const rx = vw*0.2, ry = vh*0.425, rw = vw*0.6, rh = vh*0.15;
      const frame = procCtx.getImageData(rx,ry,rw,rh);
      // Preprocess?
      if(preprocess){
        for(let i=0, d=frame.data;i<d.length;i+=4){
          const m=(d[i]+d[i+1]+d[i+2])/3;
          d[i]=d[i+1]=d[i+2]=m>128?255:0;
        }
      }
      roiCtx.putImageData(frame,0,0);

      // OCR
      const { data:{text} } = await worker.recognize(roiCanvas);
      const num = parseFloat(text.replace(/[^0-9.]/g,''))||0;

      // Update live read
      currentEl.textContent = num.toFixed(1)+' g';

      // Auto-start logic
      const now = Date.now();
      if(!autoStarted){
        if(num<=ZERO_MARGIN){
          zeroBuffer.push(now);
          if(zeroBuffer.length>ZERO_COUNT) zeroBuffer.shift();
        } else if(zeroBuffer.length>=ZERO_COUNT){
          autoStarted = true;
          dataLog=[]; logEl.innerText = '[Auto-start]';
          lastChange = now; logWeight(num);
        }
      } else {
        // log continuously
        logWeight(num);
        // reset if long idle
        if(Math.abs(num-lastWeight)>0.2) lastChange=now;
        if(now-lastChange>10000){
          autoStarted=false; zeroBuffer=[]; logEl.innerText+='\n[Reset]';
        }
      }
      lastWeight = num;

      ocrBusy = false;
      if(showLog) logEl.scrollTop = logEl.scrollHeight;
    }, 300);

  })();
  </script>
</body>
</html>
